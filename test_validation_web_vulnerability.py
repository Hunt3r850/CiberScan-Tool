#!/usr/bin/env python3
"""
Script de validación para el módulo de análisis de vulnerabilidades web.

Este script realiza pruebas unitarias para verificar el correcto
funcionamiento del módulo de análisis de vulnerabilidades web.
"""

import os
import sys
import unittest
import tempfile
import json
from unittest.mock import patch, MagicMock

# Añadir el directorio raíz al path para importar los módulos
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

from modules.web_vulnerability_scanner import WebVulnerability, WebVulnerabilityScanner, WebVulnerabilityReporter

class TestWebVulnerability(unittest.TestCase):
    """Pruebas unitarias para la clase WebVulnerability."""
    
    def test_vulnerability_creation(self):
        """Prueba la creación de un objeto WebVulnerability."""
        vuln = WebVulnerability(
            name="Cross-Site Scripting (XSS)",
            description="Una vulnerabilidad XSS permite la inyección de scripts maliciosos.",
            risk_level="High",
            confidence="Medium"
        )
        
        self.assertEqual(vuln.name, "Cross-Site Scripting (XSS)")
        self.assertEqual(vuln.description, "Una vulnerabilidad XSS permite la inyección de scripts maliciosos.")
        self.assertEqual(vuln.risk_level, "High")
        self.assertEqual(vuln.confidence, "Medium")
        self.assertIsNone(vuln.url)
        self.assertIsNone(vuln.parameter)
        self.assertIsNone(vuln.evidence)
        self.assertIsNone(vuln.solution)
        self.assertEqual(len(vuln.references), 0)
        self.assertIsNone(vuln.cwe_id)
        self.assertIsNotNone(vuln.detection_date)
        self.assertIsNone(vuln.tool)
        self.assertEqual(len(vuln.notes), 0)
        
    def test_set_url(self):
        """Prueba establecer la URL de una vulnerabilidad."""
        vuln = WebVulnerability(name="Test Vulnerability")
        vuln.set_url("http://example.com/vulnerable")
        
        self.assertEqual(vuln.url, "http://example.com/vulnerable")
        
    def test_set_parameter(self):
        """Prueba establecer el parámetro vulnerable."""
        vuln = WebVulnerability(name="Test Vulnerability")
        vuln.set_parameter("id")
        
        self.assertEqual(vuln.parameter, "id")
        
    def test_set_evidence(self):
        """Prueba establecer la evidencia de una vulnerabilidad."""
        vuln = WebVulnerability(name="Test Vulnerability")
        vuln.set_evidence("alert(1) reflected in response")
        
        self.assertEqual(vuln.evidence, "alert(1) reflected in response")
        
    def test_set_solution(self):
        """Prueba establecer la solución recomendada."""
        vuln = WebVulnerability(name="Test Vulnerability")
        vuln.set_solution("Validar y escapar todas las entradas de usuario")
        
        self.assertEqual(vuln.solution, "Validar y escapar todas las entradas de usuario")
        
    def test_add_reference(self):
        """Prueba añadir referencias a una vulnerabilidad."""
        vuln = WebVulnerability(name="Test Vulnerability")
        vuln.add_reference("https://owasp.org/www-community/attacks/xss/")
        vuln.add_reference("CWE-79")
        
        self.assertEqual(len(vuln.references), 2)
        self.assertIn("https://owasp.org/www-community/attacks/xss/", vuln.references)
        self.assertIn("CWE-79", vuln.references)
        
    def test_set_cwe_id(self):
        """Prueba establecer el identificador CWE."""
        vuln = WebVulnerability(name="Test Vulnerability")
        vuln.set_cwe_id("CWE-79")
        
        self.assertEqual(vuln.cwe_id, "CWE-79")
        
    def test_set_tool(self):
        """Prueba establecer la herramienta que detectó la vulnerabilidad."""
        vuln = WebVulnerability(name="Test Vulnerability")
        vuln.set_tool("OWASP ZAP")
        
        self.assertEqual(vuln.tool, "OWASP ZAP")
        
    def test_add_note(self):
        """Prueba añadir notas a una vulnerabilidad."""
        vuln = WebVulnerability(name="Test Vulnerability")
        vuln.add_note("Esta vulnerabilidad fue verificada manualmente")
        vuln.add_note("Requiere atención inmediata")
        
        self.assertEqual(len(vuln.notes), 2)
        self.assertEqual(vuln.notes[0], "Esta vulnerabilidad fue verificada manualmente")
        self.assertEqual(vuln.notes[1], "Requiere atención inmediata")
        
    def test_get_risk_score(self):
        """Prueba el cálculo de la puntuación de riesgo."""
        # Alto riesgo, alta confianza
        vuln1 = WebVulnerability(name="Test", risk_level="High", confidence="High")
        self.assertEqual(vuln1.get_risk_score(), 8)
        
        # Alto riesgo, confianza media
        vuln2 = WebVulnerability(name="Test", risk_level="High", confidence="Medium")
        self.assertEqual(vuln2.get_risk_score(), 6)
        
        # Riesgo medio, confianza media
        vuln3 = WebVulnerability(name="Test", risk_level="Medium", confidence="Medium")
        self.assertEqual(vuln3.get_risk_score(), 4)
        
        # Bajo riesgo, baja confianza
        vuln4 = WebVulnerability(name="Test", risk_level="Low", confidence="Low")
        self.assertEqual(vuln4.get_risk_score(), 2)
        
    def test_to_dict(self):
        """Prueba la conversión a diccionario."""
        vuln = WebVulnerability(
            name="SQL Injection",
            description="Una vulnerabilidad de inyección SQL",
            risk_level="High",
            confidence="High"
        )
        vuln.set_url("http://example.com/vulnerable")
        vuln.set_parameter("id")
        vuln.set_evidence("Error de sintaxis SQL en la respuesta")
        vuln.set_solution("Usar consultas parametrizadas")
        vuln.add_reference("https://owasp.org/www-community/attacks/SQL_Injection")
        vuln.set_cwe_id("CWE-89")
        vuln.set_tool("Scanner personalizado")
        vuln.add_note("Verificado manualmente")
        
        vuln_dict = vuln.to_dict()
        
        self.assertEqual(vuln_dict['name'], "SQL Injection")
        self.assertEqual(vuln_dict['description'], "Una vulnerabilidad de inyección SQL")
        self.assertEqual(vuln_dict['risk_level'], "High")
        self.assertEqual(vuln_dict['confidence'], "High")
        self.assertEqual(vuln_dict['url'], "http://example.com/vulnerable")
        self.assertEqual(vuln_dict['parameter'], "id")
        self.assertEqual(vuln_dict['evidence'], "Error de sintaxis SQL en la respuesta")
        self.assertEqual(vuln_dict['solution'], "Usar consultas parametrizadas")
        self.assertEqual(len(vuln_dict['references']), 1)
        self.assertEqual(vuln_dict['cwe_id'], "CWE-89")
        self.assertEqual(vuln_dict['tool'], "Scanner personalizado")
        self.assertEqual(len(vuln_dict['notes']), 1)
        self.assertEqual(vuln_dict['risk_score'], 8)

class TestWebVulnerabilityScanner(unittest.TestCase):
    """Pruebas unitarias para la clase WebVulnerabilityScanner."""
    
    def setUp(self):
        """Configuración inicial para las pruebas."""
        self.scanner = WebVulnerabilityScanner(log_level=30)  # WARNING level
        
    @patch('requests.get')
    def test_make_request(self, mock_get):
        """Prueba el método _make_request."""
        # Configurar el mock
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_get.return_value = mock_response
        
        # Realizar petición
        response = self.scanner._make_request('http://example.com')
        
        # Verificar resultado
        self.assertIsNotNone(response)
        self.assertEqual(response.status_code, 200)
        
        # Verificar que se llamó a requests.get con los parámetros correctos
        mock_get.assert_called_once()
        args, kwargs = mock_get.call_args
        self.assertEqual(args[0], 'http://example.com')
        
    @patch('requests.get')
    def test_make_request_with_timeout(self, mock_get):
        """Prueba el método _make_request con timeout."""
        # Configurar el mock para simular un timeout
        mock_get.side_effect = requests.exceptions.Timeout()
        
        # Realizar petición
        response = self.scanner._make_request('http://example.com')
        
        # Verificar resultado
        self.assertIsNone(response)
        
    @patch('requests.get')
    def test_detect_xss_vulnerabilities(self, mock_get):
        """Prueba la detección de vulnerabilidades XSS."""
        # Configurar el mock para simular una respuesta con XSS reflejado
        def mock_response_factory(url, **kwargs):
            response = MagicMock()
            response.status_code = 200
            
            # Verificar si hay un payload XSS en los parámetros
            params = kwargs.get('params', {})
            for param, value in params.items():
                if '<script>alert' in value:
                    # Simular que el payload se refleja en la respuesta
                    response.text = f'<html><body>Input: {value}</body></html>'
                    return response
            
            # Respuesta normal sin reflejo
            response.text = '<html><body>Normal page</body></html>'
            return response
            
        mock_get.side_effect = mock_response_factory
        
        # Realizar detección de XSS
        params = {'search': 'test'}
        vulnerabilities = self.scanner.detect_xss_vulnerabilities('http://example.com', params)
        
        # Verificar resultado
        self.assertEqual(len(vulnerabilities), 1)
        self.assertEqual(vulnerabilities[0].name, "Cross-Site Scripting (XSS)")
        self.assertEqual(vulnerabilities[0].risk_level, "High")
        self.assertEqual(vulnerabilities[0].parameter, "search")
        
    @patch('requests.get')
    def test_detect_sqli_vulnerabilities(self, mock_get):
        """Prueba la detección de vulnerabilidades de inyección SQL."""
        # Configurar el mock para simular una respuesta con error SQL
        def mock_response_factory(url, **kwargs):
            response = MagicMock()
            response.status_code = 200
            
            # Verificar si hay un payload SQLi en los parámetros
            params = kwargs.get('params', {})
            for param, value in params.items():
                if "'" in value:
                    # Simular un error SQL en la respuesta
                    response.text = 'MySQL Error: You have an error in your SQL syntax'
                    return response
            
            # Respuesta normal sin error
            response.text = '<html><body>Normal page</body></html>'
            return response
            
        mock_get.side_effect = mock_response_factory
        
        # Realizar detección de SQLi
        params = {'id': '1'}
        vulnerabilities = self.scanner.detect_sqli_vulnerabilities('http://example.com', params)
        
        # Verificar resultado
        self.assertEqual(len(vulnerabilities), 1)
        self.assertEqual(vulnerabilities[0].name, "SQL Injection")
        self.assertEqual(vulnerabilities[0].risk_level, "High")
        self.assertEqual(vulnerabilities[0].parameter, "id")
        
    def test_save_load_results(self):
        """Prueba guardar y cargar resultados."""
        # Crear vulnerabilidades de prueba
        vuln1 = WebVulnerability(
            name="XSS Vulnerability",
            description="Cross-Site Scripting vulnerability",
            risk_level="High",
            confidence="Medium"
        )
        vuln1.set_url("http://example.com/page1")
        
        vuln2 = WebVulnerability(
            name="SQL Injection",
            description="SQL Injection vulnerability",
            risk_level="High",
            confidence="High"
        )
        vuln2.set_url("http://example.com/page2")
        
        # Crear resultados
        results = {
            "http://example.com/page1": [vuln1],
            "http://example.com/page2": [vuln2]
        }
        
        # Guardar resultados
        fd, temp_path = tempfile.mkstemp(suffix='.json')
        os.close(fd)
        
        save_result = self.scanner.save_results(results, temp_path)
        self.assertTrue(save_result)
        
        # Cargar resultados
        loaded_results = self.scanner.load_results(temp_path)
        
        # Verificar resultados
        self.assertEqual(len(loaded_results), 2)
        self.assertEqual(len(loaded_results["http://example.com/page1"]), 1)
        self.assertEqual(len(loaded_results["http://example.com/page2"]), 1)
        self.assertEqual(loaded_results["http://example.com/page1"][0].name, "XSS Vulnerability")
        self.assertEqual(loaded_results["http://example.com/page2"][0].name, "SQL Injection")
        
        # Limpiar
        os.unlink(temp_path)

class TestWebVulnerabilityReporter(unittest.TestCase):
    """Pruebas unitarias para la clase WebVulnerabilityReporter."""
    
    def setUp(self):
        """Configuración inicial para las pruebas."""
        self.temp_dir = tempfile.mkdtemp()
        self.reporter = WebVulnerabilityReporter(output_dir=self.temp_dir, log_level=30)  # WARNING level
        
        # Crear vulnerabilidades de prueba
        self.vuln1 = WebVulnerability(
            name="XSS Vulnerability",
            description="Cross-Site Scripting vulnerability",
            risk_level="High",
            confidence="Medium"
        )
        self.vuln1.set_url("http://example.com/page1")
        self.vuln1.set_parameter("search")
        self.vuln1.set_evidence("<script>alert('XSS')</script> reflected in response")
        
        self.vuln2 = WebVulnerability(
            name="SQL Injection",
            description="SQL Injection vulnerability",
            risk_level="High",
            confidence="High"
        )
        self.vuln2.set_url("http://example.com/page2")
        self.vuln2.set_parameter("id")
        
        self.vuln3 = WebVulnerability(
            name="Open Redirect",
            description="Open Redirect vulnerability",
            risk_level="Medium",
            confidence="Medium"
        )
        self.vuln3.set_url("http://example.com/page3")
        
        # Crear resultados
        self.results = {
            "http://example.com/page1": [self.vuln1],
            "http://example.com/page2": [self.vuln2],
            "http://example.com/page3": [self.vuln3]
        }
        
    def tearDown(self):
        """Limpieza después de las pruebas."""
        import shutil
        shutil.rmtree(self.temp_dir)
        
    def test_generate_text_report(self):
        """Prueba la generación de informes de texto."""
        report_file = self.reporter.generate_text_report(self.results)
        
        # Verificar que se creó el archivo
        self.assertTrue(os.path.exists(report_file))
        
        # Verificar contenido básico
        with open(report_file, 'r') as f:
            content = f.read()
            self.assertIn("INFORME DE ANÁLISIS DE VULNERABILIDADES WEB", content)
            self.assertIn("XSS Vulnerability", content)
            self.assertIn("SQL Injection", content)
            self.assertIn("Open Redirect", content)
            self.assertIn("High: 2", content)
            self.assertIn("Medium: 1", content)
            
    def test_generate_json_report(self):
        """Prueba la generación de informes JSON."""
        report_file = self.reporter.generate_json_report(self.results)
        
        # Verificar que se creó el archivo
        self.assertTrue(os.path.exists(report_file))
        
        # Verificar contenido básico
        with open(report_file, 'r') as f:
            data = json.load(f)
            self.assertIn("metadata", data)
            self.assertIn("risk_summary", data)
            self.assertIn("urls", data)
            self.assertEqual(data["risk_summary"]["High"], 2)
            self.assertEqual(data["risk_summary"]["Medium"], 1)
            self.assertEqual(len(data["urls"]), 3)
            
    def test_generate_complete_report(self):
        """Prueba la generación de informes completos."""
        report_files = self.reporter.generate_complete_report(self.results)
        
        # Verificar que se crearon los archivos
        self.assertIn('text', report_files)
        self.assertIn('html', report_files)
        self.assertIn('json', report_files)
        
        for file_path in report_files.values():
            self.assertTrue(os.path.exists(file_path))

if __name__ == '__main__':
    unittest.main()
